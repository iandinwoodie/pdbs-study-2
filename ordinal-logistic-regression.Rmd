---
title: "Oridinal Logistic Regression"
author: "Ian Dinwoodie"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
library(MASS)
library(AER)
opts_chunk$set(echo=TRUE)
set.seed(1)
```

# General Setup

Load the dataframe and check the dimensions. We expect 963 rows and 312 columns.

```{r}
# Load the data from the csv into a data frame.
df.orig <- read.csv("data/processed.csv", header=TRUE)

# Get the original data frame dimensions.
dim(df.orig)
```

Address columns that need corrections.

```{r}
# Convert "dog_sex" into "male" columns.
df.mod <- df.orig
df.mod$male <- ifelse(df.mod$dog_sex==1, 1, 0)

# To correct the "dog_spayed" column we convert "I don't know" responses to NA.
df.mod$dog_spayed[df.mod$dog_spayed>1] <- NA

# Create dummy variables for the levels 1-4 of "behavior_prog".
# We ignore levels 5 and 6 because they are irrelevant to the question.
df.mod$behavior_prog_1 <- ifelse(df.mod$behavior_prog==1, 1, 0)
df.mod$behavior_prog_1[is.na(df.mod$behavior_prog_1)] <- 0
df.mod$behavior_prog_1 <- as.integer(df.mod$behavior_prog_1)
df.mod$behavior_prog_2 <- ifelse(df.mod$behavior_prog==2, 1, 0)
df.mod$behavior_prog_2[is.na(df.mod$behavior_prog_2)] <- 0
df.mod$behavior_prog_2 <- as.integer(df.mod$behavior_prog_2)
df.mod$behavior_prog_3 <- ifelse(df.mod$behavior_prog==3, 1, 0)
df.mod$behavior_prog_3[is.na(df.mod$behavior_prog_3)] <- 0
df.mod$behavior_prog_3 <- as.integer(df.mod$behavior_prog_3)
df.mod$behavior_prog_4 <- ifelse(df.mod$behavior_prog==4, 1, 0)
df.mod$behavior_prog_4[is.na(df.mod$behavior_prog_4)] <- 0
df.mod$behavior_prog_4 <- as.integer(df.mod$behavior_prog_4)

# Add a column indicating if the dog was found to have pain.
df.mod$pain <- ifelse(df.mod$health_iss_3==1, 1, 0)

# Add a column indicating if the dog was found to have fear/anxiety.
df.mod$fear_anxiety <- ifelse(df.mod$q02_main_2==1, 1, 0)

# Drop clicker/whistle from equipment since it is present in the behavior
# techniques.
df.mod <- subset(df.mod, select=-equipment_11)

# Correct training method entries.
# We consider dogs trained with any form of punishment to be excluded from a
# reward-only training style. We consider compulsion a form of punishment.
df.mod$punish <- ifelse(
    ((df.mod$training_methods_2==1) | (df.mod$training_methods_3==1)
     | (df.mod$training_methods_3==1)), 1, 0)
df.mod$reward <- ifelse(df.mod$punish==1, 0, df.mod$training_methods_1)
df.mod <- subset(df.mod,
             select=-c(training_methods_1, training_methods_2,
                       training_methods_3,training_methods_4))
```

Create dataframes for each severity level.

```{r}
# The severity levels are as follows:
# L1 = Has not bitten.
# L2 = Has bitten, but not punctured skin.
# L3 = Has bitten and punctured skin.
names(df.mod)[names(df.mod)=='q03_severity'] <- 'bite_severity'
df.mod$bite_severity <- ifelse(
  is.na(df.mod$bite_severity), df.mod$q03_form_5, df.mod$bite_severity)
df.mod$bite_severity <- ifelse(df.mod$bite_severity>2, 3, df.mod$bite_severity)
df.mod$bite_severity <- ifelse(df.mod$bite_severity<1, 1, df.mod$bite_severity)
df.l1 <- subset(df.mod, bite_severity==1)
df.l2 <- subset(df.mod, bite_severity==2)
df.l3 <- subset(df.mod, bite_severity==3)

df.mod <- df.l1
```

Retain only needed columns.

```{r}
# Retain only the columns to be used for analysis.
predictors <- c(
  '^male$',
  '^prof_type_\\d$',
  '^training_methods_\\d$',
  '^equipment_\\d+$',
  '^med_list_\\d+$',
  '^alt_med_type_\\d+$',
  '^behavior_prog_\\d+$',
  '^behavior_tech_used_\\d+$',
  '^pain$',
  '^fear_anxiety$',
  '^punish$',
  '^reward$'
  #'^bite_severity$'
)
outcomes <- c(
  "^agg_\\S+$"
)
pattern <- paste(c(predictors, outcomes), collapse='|')
idx <- grep(pattern, names(df.mod))
df.mod <- df.mod[, idx]
dim(df.mod)
```

```{r}
# Drop the columns that do not meet the minimum response cutoff.
binaries <- c(
  '^prof_type_\\d$',
  '^training_methods_\\d$',
  '^equipment_\\d+$',
  '^med_list_\\d+$',
  '^alt_med_type_\\d+$',
  '^behavior_tech_used_\\d+$'
)
pattern <- paste(binaries, collapse='|')
idx.binaries <- grep(pattern, names(df.mod))
drops <- NULL
for (idx in idx.binaries) {
  # We record any column with less than 5 affirmative (1) responses.
  if (sum(df.mod[,idx]) < 10) {
    drops <- c(drops, idx)
  }
}
print(names(df.mod)[drops])
df.mod <- subset(df.mod, select=-drops)

# Examine the data frame.
#summary(df.mod)
```

We also wrap reusable code in functions.

```{r}
get_agg_data_frame <- function(df, pred.patterns, outcome, excludes)
{
  pattern <- paste(c(pred.patterns, outcome), collapse='|')
  idx <- grep(pattern, names(df))
  df.out <- df[, idx]
  
  # Format the outcome as a factor with order.
  df.out[,outcome] <- round(df.out[,outcome], 0)
  df.out[,outcome] <- factor(df.out[,outcome], levels=c("1","2","3","4","5","6","7"),
                             ordered=TRUE)
  
  if (length(excludes) > 0) {
    # Exclude variables that cause issues for the model.
    df.out <- df.out[, !colnames(df.out) %in% excludes]
  }
  
  # Drop rows with null values for the outcome.
  df.out <- df.out[!is.na(df.out[,outcome]), ]
  
  return(df.out)
}

apply_binary_response_criteria <- function(df)
{
  binaries <- c(
    '^prof_type_\\d$',
    '^training_methods_\\d$',
    '^equipment_\\d+$',
    '^med_list_\\d+$',
    '^alt_med_type_\\d+$',
    '^behavior_tech_used_\\d+$',
    '^pain$',
    '^fear_anxiety$',
    '^punish$',
    '^reward$'
  )
  
  pattern <- paste(binaries, collapse='|')
  idx.binaries <- grep(pattern, names(df))
  drops <- NULL
  for (idx in idx.binaries) {
    # We record any column with less than 5 affirmative (1) responses.
    if (sum(df[,idx]) < 10) {
      drops <- c(drops, idx)
    }
  }
  
  if (length(drops) > 0) {
    # Drop the columns that did not meet the minimum response cutoff.
    df <- subset(df, select=-drops)
  }
  
  return(df)
}
```

# Overall Aggression

```{r}
# Generate the desired subset data frame.
outcome <- "agg_avg"
excludes <- vector()
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate p-values and bootstrap CIs.
coeftest(m) # p-values
odds.ratio <- exp(coef(m))
iters <- 10
b.ors <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  b.ors[,i] <- exp(coef(m))
}
ci <- t(apply(b.ors, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.tmp <- data.frame(odds.ratio, ci.low, ci.high)
df.tmp$sig <- ''
for (i in 1:nrow(df.tmp)) {
  if (is.na(df.tmp[i, 'ci.low']) | is.na(df.tmp[i, 'ci.high'])) next
  if ((df.tmp[i, 'ci.low'] < 1) & (df.tmp[i, 'ci.high'] > 1)) {
    df.tmp[i, 'sig'] <- 'x'
  }
}
print(df.tmp)
```

# Conflict Aggression

```{r}
# Generate the desired subset data frame.
outcome <- "agg_conf"
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate p-values and bootstrap CIs.
coeftest(m) # p-values
odds.ratio <- exp(coef(m))
b.ors <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  b.ors[,i] <- exp(coef(m))
}
ci <- t(apply(b.ors, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.tmp <- data.frame(odds.ratio, ci.low, ci.high)
df.tmp$sig <- ''
for (i in 1:nrow(df.tmp)) {
  if (is.na(df.tmp[i, 'ci.low']) | is.na(df.tmp[i, 'ci.high'])) next
  if ((df.tmp[i, 'ci.low'] < 1) & (df.tmp[i, 'ci.high'] > 1)) {
    df.tmp[i, 'sig'] <- 'x'
  }
}
print(df.tmp)
```

# I.D.H. Aggression

```{r}
# Generate the desired subset data frame.
outcome <- "agg_idh"
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate p-values and bootstrap CIs.
coeftest(m) # p-values
odds.ratio <- exp(coef(m))
b.ors <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  b.ors[,i] <- exp(coef(m))
}
ci <- t(apply(b.ors, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.tmp <- data.frame(odds.ratio, ci.low, ci.high)
df.tmp$sig <- ''
for (i in 1:nrow(df.tmp)) {
  if (is.na(df.tmp[i, 'ci.low']) | is.na(df.tmp[i, 'ci.high'])) next
  if ((df.tmp[i, 'ci.low'] < 1) & (df.tmp[i, 'ci.high'] > 1)) {
    df.tmp[i, 'sig'] <- 'x'
  }
}
print(df.tmp)
```

# External Aggression (People)

```{r}
# Generate the desired subset data frame.
outcome <- "agg_ext_ppl"
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate p-values and bootstrap CIs.
coeftest(m) # p-values
odds.ratio <- exp(coef(m))
b.ors <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  b.ors[,i] <- exp(coef(m))
}
ci <- t(apply(b.ors, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.tmp <- data.frame(odds.ratio, ci.low, ci.high)
df.tmp$sig <- ''
for (i in 1:nrow(df.tmp)) {
  if (is.na(df.tmp[i, 'ci.low']) | is.na(df.tmp[i, 'ci.high'])) next
  if ((df.tmp[i, 'ci.low'] < 1) & (df.tmp[i, 'ci.high'] > 1)) {
    df.tmp[i, 'sig'] <- 'x'
  }
}
print(df.tmp)
```

# External Aggression (Dogs)

```{r}
# Generate the desired subset data frame.
outcome <- "agg_ext_dog"
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
print(f)
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate p-values and bootstrap CIs.
coeftest(m) # p-values
odds.ratio <- exp(coef(m))
b.ors <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  b.ors[,i] <- exp(coef(m))
}
ci <- t(apply(b.ors, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.tmp <- data.frame(odds.ratio, ci.low, ci.high)
df.tmp$sig <- ''
for (i in 1:nrow(df.tmp)) {
  if (is.na(df.tmp[i, 'ci.low']) | is.na(df.tmp[i, 'ci.high'])) next
  if ((df.tmp[i, 'ci.low'] < 1) & (df.tmp[i, 'ci.high'] > 1)) {
    df.tmp[i, 'sig'] <- 'x'
  }
}
print(df.tmp)
```

# Predatory Aggression

```{r}
# Generate the desired subset data frame.
outcome <- "agg_pred"
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate p-values and bootstrap CIs.
coeftest(m) # p-values
odds.ratio <- exp(coef(m))
b.ors <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  b.ors[,i] <- exp(coef(m))
}
ci <- t(apply(b.ors, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.tmp <- data.frame(odds.ratio, ci.low, ci.high)
df.tmp$sig <- ''
for (i in 1:nrow(df.tmp)) {
  if (is.na(df.tmp[i, 'ci.low']) | is.na(df.tmp[i, 'ci.high'])) next
  if ((df.tmp[i, 'ci.low'] < 1) & (df.tmp[i, 'ci.high'] > 1)) {
    df.tmp[i, 'sig'] <- 'x'
  }
}
print(df.tmp)
```
