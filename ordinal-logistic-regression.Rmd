---
title: "Oridinal Logistic Regression"
author: "Ian Dinwoodie"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
library(MASS)
library(AER)
library(plyr)
opts_chunk$set(echo=TRUE)
```

# Preparing the Data

Load the dataframe and check the dimensions. We expect 963 rows and 301 columns.

```{r}
# Load the data from the csv into a data frame.
df.orig <- read.csv("data/processed.csv", header=TRUE)

# Get the original data frame dimensions.
dim(df.orig)
```

Some columns need to have their values standardized.

```{r}
# Convert "dog_sex" into "male" columns.
df.mod <- df.orig
df.mod$male <- ifelse(df.mod$dog_sex==1, 1, 0)
df.mod <- df.mod[!is.na(df.mod$male),]

# Create dummy variables for the levels 1-4 of "behavior_prog".
# We ignore levels 5 and 6 because they are irrelevant to the question.
df.mod$behavior_prog_1 <- ifelse(df.mod$behavior_prog==1, 1, 0)
df.mod$behavior_prog_1[is.na(df.mod$behavior_prog_1)] <- 0
df.mod$behavior_prog_1 <- as.integer(df.mod$behavior_prog_1)
df.mod$behavior_prog_2 <- ifelse(df.mod$behavior_prog==2, 1, 0)
df.mod$behavior_prog_2[is.na(df.mod$behavior_prog_2)] <- 0
df.mod$behavior_prog_2 <- as.integer(df.mod$behavior_prog_2)
df.mod$behavior_prog_3 <- ifelse(df.mod$behavior_prog==3, 1, 0)
df.mod$behavior_prog_3[is.na(df.mod$behavior_prog_3)] <- 0
df.mod$behavior_prog_3 <- as.integer(df.mod$behavior_prog_3)
df.mod$behavior_prog_4 <- ifelse(df.mod$behavior_prog==4, 1, 0)
df.mod$behavior_prog_4[is.na(df.mod$behavior_prog_4)] <- 0
df.mod$behavior_prog_4 <- as.integer(df.mod$behavior_prog_4)

# Add a column indicating if the dog was found to have pain.
df.mod$pain <- ifelse(df.mod$health_iss_3==1, 1, 0)

# Add a column indicating if the dog was found to have fear/anxiety.
df.mod$fear_anxiety <- ifelse(df.mod$q02_main_2==1, 1, 0)

# Correct training method entries.
# We consider dogs trained with any form of punishment to be excluded from a
# reward-only training style. We consider compulsion a form of punishment.
df.mod$punish <- ifelse(
    ((df.mod$training_methods_2==1) | (df.mod$training_methods_3==1)
     | (df.mod$training_methods_3==1)), 1, 0)
df.mod$reward <- ifelse(df.mod$punish==1, 0, df.mod$training_methods_1)
df.mod <- subset(df.mod,
             select=-c(training_methods_1, training_methods_2,
                       training_methods_3,training_methods_4))

# Drop clicker/whistle from equipment since it is present in the behavior
# techniques.
# TODO: Investigate for colinearity.
#df.mod <- subset(df.mod, select=-equipment_11)
```

Retain only the columns necessary for analysis.

```{r}
# Retain only the columns to be used for analysis.
predictors <- c(
  '^male$',
  '^prof_type_\\d$',
  '^equipment_\\d+$',
  '^med_list_\\d+$',
  '^alt_med_type_\\d+$',
  '^behavior_prog_\\d+$',
  '^behavior_tech_used_\\d+$',
  '^pain$',
  '^fear_anxiety$',
  '^punish$',
  '^reward$'
  #'^bite_severity$'
)
outcomes <- c(
  "^agg_\\S+$"
)
pattern <- paste(c(predictors, outcomes), collapse='|')
idx <- grep(pattern, names(df.mod))
df.mod <- df.mod[, idx]
dim(df.mod)
```

All remaining columns except for the response to treatment for aggression scores
are factors. Update the column types to reflect this.

```{r}
for (col in names(df.mod)) {
  if (grepl('agg_', col, fixed=TRUE)) next
  df.mod[, col] <- as.factor(df.mod[, col])
}

str(df.mod)
```

Create dataframes for each severity level.

```{r}
# The severity levels are as follows:
# L1 = Has not bitten.
# L2 = Has bitten, but not punctured skin.
# L3 = Has bitten and punctured skin.
#names(df.mod)[names(df.mod)=='q03_severity'] <- 'bite_severity'
#df.mod$bite_severity <- ifelse(
#  is.na(df.mod$bite_severity), df.mod$q03_form_5, df.mod$bite_severity)
#df.mod$bite_severity <- ifelse(df.mod$bite_severity>2, 3, df.mod$bite_severity)
#df.mod$bite_severity <- ifelse(df.mod$bite_severity<1, 1, df.mod$bite_severity)
#df.l1 <- subset(df.mod, bite_severity==1)
#df.l2 <- subset(df.mod, bite_severity==2)
#df.l3 <- subset(df.mod, bite_severity==3)

#df.mod <- df.l3
```

General rule of thumb for logistic regression is that each variable should have
at least 10 responses per response option. We apply this rule of thumb below.

```{r}
# Drop the columns that do not meet the minimum response cutoff.
apply_binary_response_criteria <- function(df)
{
  min_response_cutoff <- 10
  drops <- NULL
  for (col in names(df)) {
    if (grepl('agg_', col, fixed=TRUE)) next
    counts <- count(df[, col])
    if (nrow(counts) < 2) {
      drops <- c(drops, col)
      break
    }
    for (row in 1:nrow(counts)) {
      if (counts[row, 'freq'] < min_response_cutoff) {
        drops <- c(drops, col)
        break
      }
    }
  }
  
  return(df[, !(names(df) %in% drops)])
}

df.mod <- apply_binary_response_criteria(df.mod)
summary(df.mod)
```

Now we initialize other functions that will be reused throughout the analysis.

```{r}
get_agg_data_frame <- function(df, pred.patterns, outcome, excludes)
{
  pattern <- paste(c(pred.patterns, outcome), collapse='|')
  idx <- grep(pattern, names(df))
  df.out <- df[, idx]
  
  # Format the outcome as a factor with order.
  df.out[,outcome] <- round(df.out[,outcome], 0)
  df.out[,outcome] <- factor(df.out[,outcome], levels=c("1","2","3","4","5","6","7"),
                             ordered=TRUE)
  
  if (length(excludes) > 0) {
    # Exclude variables that cause issues for the model.
    df.out <- df.out[, !colnames(df.out) %in% excludes]
  }
  
  # Drop rows with null values for the outcome.
  df.out <- df.out[!is.na(df.out[,outcome]), ]
  
  return(df.out)
}

get_bootstrapped_ci <- function(df, f, start, odds.ratio, iters=10)
{
  mx.or <- matrix(, nrow=length(odds.ratio), ncol=iters)
  for (i in 1:iters) {
    df.tmp <- df[sample(nrow(df), nrow(df), replace=T), ]
    m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
    mx.or[,i] <- exp(coef(m))
  }
  
  ci <- t(apply(mx.or, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
  ci.low <- ci[,1]
  ci.high <- ci[,2]
  
  df.results <- data.frame(odds.ratio, ci.low, ci.high)
  df.results$ci.x <- ''
  for (i in 1:nrow(df.results)) {
    if (is.na(df.results[i, 'ci.low']) | is.na(df.results[i, 'ci.high'])) next
    if ((df.results[i, 'ci.low'] < 1) & (df.results[i, 'ci.high'] > 1)) {
      df.results[i, 'ci.x'] <- 'yes'
    }
  }
  
  return(df.results)
}
```

# Overall Aggression

```{r}
set.seed(1)

# Generate the desired subset data frame.
outcome <- "agg_avg"
excludes <- vector()
df.agg <- apply_binary_response_criteria(
    get_agg_data_frame(df.mod, predictors, outcome, excludes))
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate CIs and p-values.
coeftest(m) # p-values
ci <- exp(confint.default(m))
odds.ratio <- exp(coef(m))
cbind(odds.ratio, ci) # OR and CI

# Generate p-values and bootstrap CIs.
print(get_bootstrapped_ci(df.agg, f, start, odds.ratio, iters=100))
```

# Conflict Aggression

```{r}
# Generate the desired subset data frame.
outcome <- "agg_conf"
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate CIs and p-values.
coeftest(m) # p-values
ci <- exp(confint.default(m))
odds.ratio <- exp(coef(m))
cbind(odds.ratio, ci) # OR and CI

# Generate p-values and bootstrap CIs.
mx.or <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  mx.or[,i] <- exp(coef(m))
}
ci <- t(apply(mx.or, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.results <- data.frame(odds.ratio, ci.low, ci.high)
df.results$sig <- ''
for (i in 1:nrow(df.results)) {
  if (is.na(df.results[i, 'ci.low']) | is.na(df.results[i, 'ci.high'])) next
  if ((df.results[i, 'ci.low'] < 1) & (df.results[i, 'ci.high'] > 1)) {
    df.results[i, 'sig'] <- 'x'
  }
}
print(df.results)
```

# I.D.H. Aggression

```{r}
# Generate the desired subset data frame.
outcome <- "agg_idh"
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate CIs and p-values.
coeftest(m) # p-values
ci <- exp(confint.default(m))
odds.ratio <- exp(coef(m))
cbind(odds.ratio, ci) # OR and CI

# Generate p-values and bootstrap CIs.
mx.or <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  mx.or[,i] <- exp(coef(m))
}
ci <- t(apply(mx.or, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.results <- data.frame(odds.ratio, ci.low, ci.high)
df.results$sig <- ''
for (i in 1:nrow(df.results)) {
  if (is.na(df.results[i, 'ci.low']) | is.na(df.results[i, 'ci.high'])) next
  if ((df.results[i, 'ci.low'] < 1) & (df.results[i, 'ci.high'] > 1)) {
    df.results[i, 'sig'] <- 'x'
  }
}
print(df.results)
```

# External Aggression (People)

```{r}
# Generate the desired subset data frame.
outcome <- "agg_ext_ppl"
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate CIs and p-values.
coeftest(m) # p-values
ci <- exp(confint.default(m))
odds.ratio <- exp(coef(m))
cbind(odds.ratio, ci) # OR and CI

# Generate p-values and bootstrap CIs.
mx.or <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  mx.or[,i] <- exp(coef(m))
}
ci <- t(apply(mx.or, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.results <- data.frame(odds.ratio, ci.low, ci.high)
df.results$sig <- ''
for (i in 1:nrow(df.results)) {
  if (is.na(df.results[i, 'ci.low']) | is.na(df.results[i, 'ci.high'])) next
  if ((df.results[i, 'ci.low'] < 1) & (df.results[i, 'ci.high'] > 1)) {
    df.results[i, 'sig'] <- 'x'
  }
}
print(df.results)
```

# External Aggression (Dogs)

```{r}
# Generate the desired subset data frame.
outcome <- "agg_ext_dog"
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
print(f)
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate CIs and p-values.
coeftest(m) # p-values
ci <- exp(confint.default(m))
odds.ratio <- exp(coef(m))
cbind(odds.ratio, ci) # OR and CI

# Generate p-values and bootstrap CIs.
mx.or <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  mx.or[,i] <- exp(coef(m))
}
ci <- t(apply(mx.or, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.results <- data.frame(odds.ratio, ci.low, ci.high)
df.results$sig <- ''
for (i in 1:nrow(df.results)) {
  if (is.na(df.results[i, 'ci.low']) | is.na(df.results[i, 'ci.high'])) next
  if ((df.results[i, 'ci.low'] < 1) & (df.results[i, 'ci.high'] > 1)) {
    df.results[i, 'sig'] <- 'x'
  }
}
print(df.results)
```

# Predatory Aggression

```{r}
# Generate the desired subset data frame.
outcome <- "agg_pred"
df.agg <- get_agg_data_frame(df.mod, predictors, outcome, excludes)
df.agg <- apply_binary_response_criteria(df.agg)
dim(df.agg)

# Fit a logistic regression.
f <- as.formula(paste0(outcome, "~", "."))
coef <- rep(0, length(df.agg)-1)
zeta <- seq(from=0, to=1, length.out=6)
start <- c(coef, zeta)
m <- polr(f, data=df.agg, Hess=TRUE, start=start)
summary(m)

# Generate CIs and p-values.
coeftest(m) # p-values
ci <- exp(confint.default(m))
odds.ratio <- exp(coef(m))
cbind(odds.ratio, ci) # OR and CI

# Generate p-values and bootstrap CIs.
mx.or <- matrix(, nrow=length(odds.ratio), ncol=iters)
for (i in 1:iters) {
  df.tmp <- df.agg[sample(nrow(df.agg), nrow(df.agg), replace=T), ]
  m <- polr(f, data=df.tmp, Hess=TRUE, start=start)
  mx.or[,i] <- exp(coef(m))
}
ci <- t(apply(mx.or, 1, quantile, probs=c(0.025, 0.975), na.rm=TRUE))
ci.low <- ci[,1]
ci.high <- ci[,2]
df.results <- data.frame(odds.ratio, ci.low, ci.high)
df.results$sig <- ''
for (i in 1:nrow(df.results)) {
  if (is.na(df.results[i, 'ci.low']) | is.na(df.results[i, 'ci.high'])) next
  if ((df.results[i, 'ci.low'] < 1) & (df.results[i, 'ci.high'] > 1)) {
    df.results[i, 'sig'] <- 'x'
  }
}
print(df.results)
```
